\subsection*{Overview }

This package provides a set of classes which define the interface to Wire Cell. Software from the other Wire Cell packages that provides Wire Cell functionality do so through implementing these interfaces and by calling into them. Outside \char`\"{}client\char`\"{} code that wishes to use Wire Cell code directly should do so by compiling and linking against this package. In general there should not be direct compilation or linking against any higher level package in Wire Cell.

\subsection*{Component Interfaces }

Major facets of Wire Cell inherit from a subclass of {\ttfamily \hyperlink{class_wire_cell_1_1_interface}{Wire\+Cell\+::\+Interface}} (which is actually provided by {\ttfamily util}). Such classes have a (non-\/const) {\ttfamily shared\+\_\+ptr} defined by the base class as these facets tend to be shared by multiple client code. The concrete implementation of an Interface register through the {\ttfamily \hyperlink{class_wire_cell_1_1_named_factory}{Wire\+Cell\+::\+Named\+Factory}} mechanism which allows dynamic construction.

\subsection*{Data Interfaces }

The data objects which Wire Cell produces and operates on are defined through interface classes as well. Their interfaces do not inherent from {\ttfamily \hyperlink{class_wire_cell_1_1_interface}{Wire\+Cell\+::\+Interface}} as components. Rather, all data interface classes inherit from {\ttfamily \hyperlink{class_wire_cell_1_1_i_data}{Wire\+Cell\+::\+I\+Data}$<$Data$>$}, which is templated on the data interface class itself. See for example {\ttfamily \hyperlink{class_wire_cell_1_1_i_wire}{Wire\+Cell\+::\+I\+Wire}}.

Every data interface class has a number of types defined including a (const) {\ttfamily shared\+\_\+ptr}, a base iterator as well as an abstract iterator and iterator range. Also defined are types for Wire Cell signal/slot mechanism which is described more below.

Some specific data interface also define some types for convenience such as providing a common vector collection. These types follow a common naming convention, for example\+: {\ttfamily Wire\+Cell\+::\+I\+Wire\+Vector}, {\ttfamily Wire\+Cell\+::\+I\+Cell\+Vector} and {\ttfamily Wire\+Cell\+::\+I\+Plane\+Slice\+Vector}.

There are also interfaces for sequences of data to provide light-\/weight memory views which act like simple iterators but which may hide more complex data structures. For example, cells can be stored in a memory-\/efficient graph structure which also provides fast associations. For simple iteration it is best to reuse that structure while providing \char`\"{}familiar\char`\"{} iterators.

Some of the important data interfaces include\+:


\begin{DoxyItemize}
\item {\bfseries wire} a segment of wire with physical endpoints and associations to channel and an index into its plane of wires.
\item {\bfseries cell} a region of space in the wire plane associated with one wire from each.
\item {\bfseries blob} a collection of cells which itself implements the cell data interface.
\item {\bfseries wire summary tiling} implement common queries on wires and cells.
\item {\bfseries wire plane and channel slices} implement access to information about charge in a slice in time across either a plane of wires or a detectors readout channels
\end{DoxyItemize}

\section*{Signal/\+Slot }

Wire Cell implements a pattern called \char`\"{}data flow programming\char`\"{} (D\+FP). Instead of just calling functions with arguments and accepting their returned results, D\+FP allows for high level \char`\"{}flow networks\char`\"{} to be defined by connecting together functional {\itshape units} (objects) by attaching one unit\textquotesingle{}s output to another unit\textquotesingle{}s input.

The reasons to follow the D\+FP paradigm are\+:


\begin{DoxyItemize}
\item minimize the amount of data that must be buffered into memory at any one time.
\item reduce the coupling between units.
\item support multiple computing architectures (single-\/processor, multi-\/processor, massive parallelism, C\+P\+U/\+G\+PU) with maximal code reuse.
\end{DoxyItemize}

Boost\textquotesingle{}s Signal/\+Slot {\ttfamily boost\+::signals2} mechanism is used. Components which accept D\+FP input stream have a signal object which accepts connections of slots matching a particular functional prototype. Depending on the nature unit it may be that only a single connection is allowed or that multiple ones can be made and possibly in a predetermined order.

When the unit requires new data it \char`\"{}fires\char`\"{} (calls) its signal which calls its slots and returns to the calling unit their return value(s).

Typically a slot is implemented as a {\ttfamily I\+Data\+::pointer operator()()} method which lacks any arguments. But, in some cases such as {\ttfamily \hyperlink{class_wire_cell_1_1_fanout}{Wire\+Cell\+::\+Fanout}} slot arguments may be required and are passed in through the signal call. See also {\ttfamily \hyperlink{class_wire_cell_1_1_addresser}{Wire\+Cell\+::\+Addresser}} which binds a argument to pass at construction time which may be used to access a particular \char`\"{}jack\char`\"{} of a {\ttfamily \hyperlink{class_wire_cell_1_1_fanout}{Wire\+Cell\+::\+Fanout}}. 